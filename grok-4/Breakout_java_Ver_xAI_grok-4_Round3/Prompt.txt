(เขียนมาใหม่) ส่วนที่ 2: คำสั่งสำหรับสร้าง JUnit Tests
1. วัตถุประสงค์หลัก
หน้าที่ของคุณคือการเขียนชุดการทดสอบ JUnit (Unit Tests) ที่ครอบคลุมสมบูรณ์สำหรับโค้ดเกม Breakout ที่จะได้รับ
2. ข้อกำหนดด้านคุณภาพที่สำคัญที่สุด
ชุดการทดสอบที่สร้างขึ้น จะต้อง เป็นไปตามเกณฑ์ชี้วัดความครอบคลุม (Coverage Criteria) ดังต่อไปนี้:
Statement Coverage: 100%
Branch Coverage: 100%
คุณต้องเขียน Test Case ที่จำเป็นทั้งหมดเพื่อให้แน่ใจว่าทุกบรรทัดของโค้ดและทุกเงื่อนไขที่เป็นไปได้ทุกไฟล์ (เช่น if/else) จะถูกทำงานระหว่างการทดสอบ และต้องเขียนคอมเม้นบอกว่า Test แต่ละตัวทำอะไรให้ชัดเจนเป็นภาษาไทย และให้มีไฟล์ TestRunner สำหรับเรียกไฟล์ JUnit ทั้งหมดในการรันครั้งเดียว และเขียนสรุป test case ทั้งหมดออกมาลิสเป็นข้อๆ บอก 1.ชื่อไฟล์JUnit  2.ชื่อ test ภายในไฟล์ JUnit 3.รายละเอียดการtest ภายในไฟล์ว่าตัวนี้ test อะไรพร้อม Expected Result เป็นตารางให้อ่ายง่ายเป็นภาษาไทย
3. วิธีการ
นี่คือโค้ด Java ของเกม Breakout ที่สมบูรณ์ หน้าที่ของคุณคือส่งมอบโค้ด JUnit5 Test ที่สมบูรณ์ทั้งหมดเพื่อให้บรรลุเป้าหมาย Statement และ Branch Coverage 100% และให้โค้ดสั้นแต่ไม่กระทบประสิทธิภาพ และแยกการไฟล์ JUnit  เป็นหลายๆไฟล์ ตาม classที่จะเทส (โดยยึดข้อมูลจากไฟล์เหล่านี้ 
package Game;

public class Ball {
    private int x, y, width, height, dx, dy;

    public Ball(int x, int y, int width, int height, int dx, int dy) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.dx = dx;
        this.dy = dy;
    }

    public void move() {
        x += dx;
        y += dy;
    }

    public void reverseDx() { dx = -dx; }
    public void reverseDy() { dy = -dy; }

    public boolean intersects(int objX, int objY, int objWidth, int objHeight) {
        return x < objX + objWidth && x + width > objX &&
               y < objY + objHeight && y + height > objY;
    }

    public int getX() { return x; }
    public int getY() { return y; }
    public int getWidth() { return width; }
    public int getHeight() { return height; }
}

package Game;

import javax.swing.JFrame;

public class Breakout {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Breakout");
        GamePanel panel = new GamePanel();
        frame.add(panel);
        frame.setSize(300, 400);
        frame.setResizable(false);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
        panel.requestFocusInWindow(); // Ensure panel gets key events
    }
}

package Game;

public class Brick {
    private int x, y, width, height;
    private boolean destroyed = false;

    public Brick(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    public void destroy() { destroyed = true; }
    public boolean isDestroyed() { return destroyed; }

    public int getX() { return x; }
    public int getY() { return y; }
    public int getWidth() { return width; }
    public int getHeight() { return height; }
}

package Game;

import javax.swing.JPanel;
import javax.swing.Timer;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

public class GamePanel extends JPanel implements ActionListener {
    private static final int WIDTH = 300;
    private static final int HEIGHT = 400;
    private static final int DELAY = 10; // Milliseconds between updates

    private Timer timer;
    private Paddle paddle;
    private Ball ball;
    private Brick[] bricks;
    private boolean gameOver = false;
    private boolean victory = false;
    private int bricksDestroyed = 0;
    private static final int NUM_BRICKS = 30;
    private static final int ROWS = 5;
    private static final int COLS = 6;
    private static final int BRICK_WIDTH = WIDTH / COLS;
    private static final int BRICK_HEIGHT = 20;

    public GamePanel() {
        setBackground(Color.BLACK);
        setFocusable(true);
        addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (!gameOver && !victory) {
                    paddle.move(e.getKeyCode());
                }
            }
        });

        // Initialize game objects
        paddle = new Paddle(WIDTH / 2 - 30, HEIGHT - 50, 60, 10);
        ball = new Ball(WIDTH / 2 - 10, HEIGHT / 2, 20, 20, 2, -2); // Initial velocity
        bricks = new Brick[NUM_BRICKS];
        initBricks();

        // Start game automatically
        timer = new Timer(DELAY, this);
        timer.start();
    }

    private void initBricks() {
        int index = 0;
        for (int row = 0; row < ROWS; row++) {
            for (int col = 0; col < COLS; col++) {
                int x = col * BRICK_WIDTH;
                int y = row * BRICK_HEIGHT + 20; // Offset from top
                bricks[index++] = new Brick(x, y, BRICK_WIDTH, BRICK_HEIGHT);
            }
        }
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (!gameOver && !victory) {
            ball.move();
            checkCollisions();
        }
        repaint();
    }

    public void checkCollisions() {
        // Ball with walls
        if (ball.getX() <= 0 || ball.getX() >= WIDTH - ball.getWidth()) {
            ball.reverseDx();
        }
        if (ball.getY() <= 0) {
            ball.reverseDy();
        }
        if (ball.getY() >= HEIGHT - ball.getHeight()) {
            gameOver = true;
            timer.stop();
            return;
        }

        // Ball with paddle
        if (ball.intersects(paddle.getX(), paddle.getY(), paddle.getWidth(), paddle.getHeight())) {
            ball.reverseDy(); // Simple realistic bounce (reverse vertical)
        }

        // Ball with bricks
        for (Brick brick : bricks) {
            if (!brick.isDestroyed() && ball.intersects(brick.getX(), brick.getY(), brick.getWidth(), brick.getHeight())) {
                brick.destroy();
                bricksDestroyed++;
                ball.reverseDy(); // Simple realistic bounce (reverse vertical)
                if (bricksDestroyed == NUM_BRICKS) {
                    victory = true;
                    timer.stop();
                }
                break; // Only destroy one brick per frame
            }
        }
    }

    @Override
	public void paintComponent(Graphics g) {
        super.paintComponent(g);

        // Draw paddle
        g.setColor(Color.WHITE);
        g.fillRect(paddle.getX(), paddle.getY(), paddle.getWidth(), paddle.getHeight());

        // Draw ball
        g.setColor(Color.RED);
        g.fillOval(ball.getX(), ball.getY(), ball.getWidth(), ball.getHeight());

        // Draw bricks
        g.setColor(Color.GREEN);
        for (Brick brick : bricks) {
            if (!brick.isDestroyed()) {
                g.fillRect(brick.getX(), brick.getY(), brick.getWidth(), brick.getHeight());
            }
        }

        // Draw game over or victory message
        g.setColor(Color.WHITE);
        if (gameOver) {
            g.drawString("Game Over", WIDTH / 2 - 40, HEIGHT / 2);
        } else if (victory) {
            g.drawString("Victory", WIDTH / 2 - 30, HEIGHT / 2);
        }
    }
}

package Game;

import java.awt.event.KeyEvent;

public class Paddle {
    private int x, y, width, height;
    private static final int SPEED = 5;
    private static final int GAME_WIDTH = 300;

    public Paddle(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    public void move(int keyCode) {
        if (keyCode == KeyEvent.VK_LEFT && x > 0) {
            x -= SPEED;
        } else if (keyCode == KeyEvent.VK_RIGHT && x < GAME_WIDTH - width) {
            x += SPEED;
        }
    }

    public int getX() { return x; }
    public int getY() { return y; }
    public int getWidth() { return width; }
    public int getHeight() { return height; }
}


)
